/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import type {
  ApiResponseVoid,
  HandleFailoverBody,
  HandlePrometheusAlertBody,
  HandleRecoveryBody,
  HandleTopologyRecoveryBody,
} from "../../model";

import { customInstance } from "../../custom-instance";

/**
 * @summary Handle Prometheus alert
 */
export const handlePrometheusAlert = (
  handlePrometheusAlertBody: HandlePrometheusAlertBody,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/webhooks/prometheus/alert`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: handlePrometheusAlertBody,
    signal,
  });
};

export const getHandlePrometheusAlertMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof handlePrometheusAlert>>,
    TError,
    { data: HandlePrometheusAlertBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof handlePrometheusAlert>>,
  TError,
  { data: HandlePrometheusAlertBody },
  TContext
> => {
  const mutationKey = ["handlePrometheusAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof handlePrometheusAlert>>,
    { data: HandlePrometheusAlertBody }
  > = (props) => {
    const { data } = props ?? {};

    return handlePrometheusAlert(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type HandlePrometheusAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof handlePrometheusAlert>>
>;
export type HandlePrometheusAlertMutationBody = HandlePrometheusAlertBody;
export type HandlePrometheusAlertMutationError = unknown;

/**
 * @summary Handle Prometheus alert
 */
export const useHandlePrometheusAlert = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof handlePrometheusAlert>>,
      TError,
      { data: HandlePrometheusAlertBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof handlePrometheusAlert>>,
  TError,
  { data: HandlePrometheusAlertBody },
  TContext
> => {
  const mutationOptions = getHandlePrometheusAlertMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Handle Orchestrator topology recovery event
 */
export const handleTopologyRecovery = (
  handleTopologyRecoveryBody: HandleTopologyRecoveryBody,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/webhooks/orchestrator/topology-recovery`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: handleTopologyRecoveryBody,
    signal,
  });
};

export const getHandleTopologyRecoveryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof handleTopologyRecovery>>,
    TError,
    { data: HandleTopologyRecoveryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof handleTopologyRecovery>>,
  TError,
  { data: HandleTopologyRecoveryBody },
  TContext
> => {
  const mutationKey = ["handleTopologyRecovery"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof handleTopologyRecovery>>,
    { data: HandleTopologyRecoveryBody }
  > = (props) => {
    const { data } = props ?? {};

    return handleTopologyRecovery(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type HandleTopologyRecoveryMutationResult = NonNullable<
  Awaited<ReturnType<typeof handleTopologyRecovery>>
>;
export type HandleTopologyRecoveryMutationBody = HandleTopologyRecoveryBody;
export type HandleTopologyRecoveryMutationError = unknown;

/**
 * @summary Handle Orchestrator topology recovery event
 */
export const useHandleTopologyRecovery = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof handleTopologyRecovery>>,
      TError,
      { data: HandleTopologyRecoveryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof handleTopologyRecovery>>,
  TError,
  { data: HandleTopologyRecoveryBody },
  TContext
> => {
  const mutationOptions = getHandleTopologyRecoveryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Handle Orchestrator recovery event
 */
export const handleRecovery = (
  handleRecoveryBody: HandleRecoveryBody,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/webhooks/orchestrator/recovery`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: handleRecoveryBody,
    signal,
  });
};

export const getHandleRecoveryMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof handleRecovery>>,
    TError,
    { data: HandleRecoveryBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof handleRecovery>>,
  TError,
  { data: HandleRecoveryBody },
  TContext
> => {
  const mutationKey = ["handleRecovery"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof handleRecovery>>,
    { data: HandleRecoveryBody }
  > = (props) => {
    const { data } = props ?? {};

    return handleRecovery(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type HandleRecoveryMutationResult = NonNullable<
  Awaited<ReturnType<typeof handleRecovery>>
>;
export type HandleRecoveryMutationBody = HandleRecoveryBody;
export type HandleRecoveryMutationError = unknown;

/**
 * @summary Handle Orchestrator recovery event
 */
export const useHandleRecovery = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof handleRecovery>>,
      TError,
      { data: HandleRecoveryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof handleRecovery>>,
  TError,
  { data: HandleRecoveryBody },
  TContext
> => {
  const mutationOptions = getHandleRecoveryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Handle Orchestrator failover event
 */
export const handleFailover = (
  handleFailoverBody: HandleFailoverBody,
  signal?: AbortSignal,
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/webhooks/orchestrator/failover`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: handleFailoverBody,
    signal,
  });
};

export const getHandleFailoverMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof handleFailover>>,
    TError,
    { data: HandleFailoverBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof handleFailover>>,
  TError,
  { data: HandleFailoverBody },
  TContext
> => {
  const mutationKey = ["handleFailover"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof handleFailover>>,
    { data: HandleFailoverBody }
  > = (props) => {
    const { data } = props ?? {};

    return handleFailover(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type HandleFailoverMutationResult = NonNullable<
  Awaited<ReturnType<typeof handleFailover>>
>;
export type HandleFailoverMutationBody = HandleFailoverBody;
export type HandleFailoverMutationError = unknown;

/**
 * @summary Handle Orchestrator failover event
 */
export const useHandleFailover = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof handleFailover>>,
      TError,
      { data: HandleFailoverBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof handleFailover>>,
  TError,
  { data: HandleFailoverBody },
  TContext
> => {
  const mutationOptions = getHandleFailoverMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
